#!/usr/bin/env zsh

# A single script that monitors each of the following for updates:
#     Homebrew (command line programs)
#     Homebrew's Casks (GUI apps)
#     Mac App Store (flakily, as the mas tool struggles at times)
#     Python, Node.js LTS, and Ruby environments
#     Stable branch of Rust toolchain
#
# Specifically does not monitor packages within script environments;
#   those might be pinned to specific versions and need to be checked
#   individually.

local -a envs=(brew cask mas python node ruby rust)
local -a cmds=(check up)

if [[ $(uname -m) == 'arm64' ]]; then
  hbdir=/opt/homebrew
else
  hbdir=/usr/local
fi
bindir=$hbdir/bin

help() {
    echo "Usage: envup [check|up] [environment]"
    echo "    defaults: envup check all"
}


all_check() {
    $bindir/brew update > /dev/null 2>&1
    source $(which env_parallel.zsh)
    env_parallel --keep-order {}_check all ::: ${envs[@]}
}

all_up() {
    echo "Update individually for now."
    exit 1
}


print_check() {
    if [[ $2 != $3 ]]; then
        echo "  ‚ö†Ô∏è   $1 latest version is $3; installed is $2."
    else
        echo "  ‚úÖ  $1 is up to date. ($2)"
    fi
}


brew_check() {
    if [[ $1 != "all" ]]; then
        $bindir/brew update > /dev/null 2>&1
    fi
    if [[ $? -ne 0 ]]; then
        echo "  ‚ùå  Couldn‚Äôt check Homebrew packages. Internet down?"
        return
    fi
    local outBrew=$($bindir/brew outdated --formula --quiet)
    local outFmt=$(echo $outBrew | xargs | sed -e "s/ /, /g")
    local outCount=$(echo $outBrew | wc -l | xargs)
    local info=""
    if [[ ${#outBrew} == 0 ]]; then
        info="  ‚úÖ  Homebrew packages are up to date."
    elif [[ $outCount == 1 ]]; then
        info="  ‚ö†Ô∏è   Homebrew has 1 outdated package. ($outFmt)"
    else
        info="  ‚ö†Ô∏è   Homebrew has $outCount outdated packages. ($outFmt)"
    fi

    echo ${info} | fold -s -w $COLUMNS
}

brew_up() {
    HOMEBREW_NO_AUTO_UPDATE=1 $bindir/brew -v upgrade --formula
    $bindir/brew cleanup -s
    rm -rf $($bindir/brew --cache)
    brew_check
}


cask_check() {
    if [[ $1 != "all" ]]; then
        $bindir/brew update > /dev/null 2>&1
    fi
    if [[ $? -ne 0 ]]; then
        echo "  ‚ùå  Couldn‚Äôt check Homebrew casks. Internet down?"
        return
    fi
    local outCask=$($bindir/brew outdated --cask --quiet)
    local outFmt=$(echo $outCask | xargs | sed -e "s/ /, /g")
    local outCount=$(echo $outCask | wc -l | xargs)
    local info=""
    if [[ ${#outCask} == 0 ]]; then
        info="  ‚úÖ  Homebrew casks are up to date."
    elif [[ $outCount == 1 ]]; then
        info="  ‚ö†Ô∏è   Homebrew has 1 outdated cask. ($outFmt)"
    else
        info="  ‚ö†Ô∏è   Homebrew has $outCount outdated casks. ($outFmt)"
    fi

    echo ${info} | fold -s -w $COLUMNS
}

cask_up() {
    HOMEBREW_NO_AUTO_UPDATE=1 $bindir/brew -v upgrade --cask
    # $bindir/brew cleanup
    rm -rf $($bindir/brew --cache)
    echo "  ‚úÖ  Homebrew casks are up to date."
}


mas_check() {
    # <sigh> no "--quiet" modifier for mas :-/
    local outMas=$($bindir/mas outdated | sed -E 's/^[0-9]+[[:space:]]+(.*)[[:space:]]+\([0-9.]*[[:space:]]+->[[:space:]]+[0-9.]*\)$/\1/')
    local outFmt=$(echo $outMas | paste -düêº -s - | sed -e "s/üêº/, /g")
    local outCount=$(echo $outMas | wc -l | xargs)
    local info=""
    if [[ ${#outMas} == 0 ]]; then
        info="  ‚úÖ  Mac App Store apps are up to date."
    elif [[ $outCount == 1 ]]; then
        info="  ‚ö†Ô∏è   Mac App Store has 1 outdated app. ($outFmt)"
    else
        info="  ‚ö†Ô∏è   Mac App Store has $outCount outdated apps. ($outFmt)"
    fi

    echo ${info} | fold -s -w $COLUMNS
}

mas_up() {
    $bindir/mas upgrade
    echo "  ‚úÖ  Mac App Store apps are up to date."
}


env_remVer() {
    asdf list all $1 2>&1 \
        | grep -vE "\s*[a-zA-Z-]" \
        | sort -V \
        | grep "^\s*$2" \
        | tail -1 \
        | xargs
}
env_locVer() {
    asdf list $1 \
        | grep "^\s*\*$2" \
        | xargs \
        | sed 's/^\**//g'
}

env_check() {
    local remoteVersion=$( env_remVer $1 $2 )
    local localVersion=$( env_locVer $1 $2 )

    print_check $3 $localVersion $remoteVersion
}

env_migration_failed() {
    {
        echo
        echo "MIGRATION FAILED"
        echo
        echo "Inspect the requirements file: $REQ_FILE"
    } 2>&1
    exit
}


node_check() {
    asdf plugin update nodejs > /dev/null 2>&1
    env_check nodejs "\d*[02468]\." "Node.js LTS"
}

node_up() {
    local newVersion=$( env_remVer nodejs "\d*[02468]\." )
    local oldVersion=$( env_locVer nodejs "\d*[02468]\." )

    if [[ $newVersion == $oldVersion ]]; then
        print_check "Node.js LTS" $newVersion $newVersion
        return
    fi

    NODEJS_CHECK_SIGNATURES="no" asdf install nodejs $newVersion

    trap env_migration_failed ERR
        local seed="$(date '+%Y%m%d%H%M%S').$$"
        local REQ_FILE="$HOME/node-npmfile.$seed.txt"
        ~/.asdf/installs/nodejs/$oldVersion/bin/npm list --global --depth=0 \
            | tail -n +2 \
            | cut -d" " -f2 \
            | grep -v "npm@" \
            > "$REQ_FILE"

        asdf global nodejs $newVersion
        ASDF_SKIP_RESHIM=1 ~/.asdf/installs/nodejs/$newVersion/bin/npm install --global npm
        ASDF_SKIP_RESHIM=1 ~/.asdf/installs/nodejs/$newVersion/bin/npm install --global $(cat "$REQ_FILE")
        asdf reshim nodejs
        asdf uninstall nodejs $oldVersion
        rm "$REQ_FILE"
        print_check "Node.js LTS" $newVersion $newVersion
    trap - ERR
}

python_check() {
    asdf plugin update python > /dev/null 2>&1
    env_check python 3 "Python"
}

python_up() {
    local newVersion=$( env_remVer python 3 )
    local oldVersion=$( env_locVer python 3 )

    if [[ $newVersion == $oldVersion ]]; then
        print_check "Python" $newVersion $newVersion
        return
    fi

    LDFLAGS="-L$hbdir/opt/zlib/lib -L$hbdir/opt/sqlite/lib" \
        CPPFLAGS="-I$hbdir/opt/zlib/include -I$hbdir/opt/sqlite/include" \
        PYTHON_CONFIGURE_OPTS="--enable-shared" \
        asdf install python $newVersion
    asdf global python $newVersion
    asdf reshim python

    trap env_migration_failed ERR
        local seed="$(date '+%Y%m%d%H%M%S').$$"
        local REQ_FILE="$HOME/python3.requirements.$seed.txt"
        ~/.asdf/installs/python/$oldVersion/bin/pip freeze | grep -v "^-e" > "$REQ_FILE"
        ~/.asdf/installs/python/$newVersion/bin/python -m pip install --upgrade pip
        ~/.asdf/installs/python/$newVersion/bin/pip install wheel
        ~/.asdf/installs/python/$newVersion/bin/pip install -r "$REQ_FILE"
        asdf uninstall python $oldVersion
        asdf reshim python
        rm "$REQ_FILE"
        print_check "Python 3" $newVersion $newVersion
    trap - ERR
}


ruby_check() {
    asdf plugin update ruby > /dev/null 2>&1
    env_check ruby 3 "Ruby"
}

ruby_up() {
    local newVersion=$( env_remVer ruby 3 )
    local oldVersion=$( env_locVer ruby 3 )

    if [[ $newVersion == $oldVersion ]]; then
        print_check "Ruby" $newVersion $newVersion
        return
    fi

    RUBY_CONFIGURE_OPTS="--with-openssl-dir=$(brew --prefix openssl@1.1)" \
        asdf install ruby $newVersion
    asdf global ruby $newVersion
    asdf reshim ruby

    local newGem=~/.asdf/installs/ruby/$newVersion/bin/gem
    local oldGem=~/.asdf/installs/ruby/$oldVersion/bin/gem

    trap env_migration_failed ERR
        local seed="$(date '+%Y%m%d%H%M%S').$$"
        local REQ_FILE="$HOME/ruby-gemfile.$seed.txt"
        $oldGem list > "$REQ_FILE"
        $newGem update --system
        yes | $newGem update
        for i in $($oldGem list | awk '{ if ( $1 !~ /^$/ ) print $1}'); do
            if [[ $($newGem list "${i}") != *"${i}"* ]]; then
                $newGem install -f "${i}"
            fi
        done

        asdf uninstall ruby $oldVersion
        asdf reshim ruby
        rm "$REQ_FILE"
        print_check "Ruby" $newVersion $newVersion
    trap - ERR
}


rust_check() {
    local rustStatus=$(rustup check | grep stable)
    local currentVersion=$(echo $rustStatus | sed -n -E "s/^.*: ([[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+).*$/\1/p")

    local info=""
    if echo $rustStatus | grep -q "Up to date"; then
        info="  ‚úÖ  Rust is up to date. ($currentVersion)"
    else
        local newVersion=$(echo $rustStatus | sed -n -E "s/^.*-> ([[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+).*$/\1/p")
        info="  ‚ö†Ô∏è   Rust latest version is $newVersion; installed is $currentVersion."
    fi

    echo ${info} | fold -s -w $COLUMNS
}

rust_up() {
    rustup update stable
    rust_check
}


[[ $ZSH_EVAL_CONTEXT =~ :file$ ]] && sourced=1 || sourced=0
if [[ $sourced -ne 1 ]]; then
    local val=""
    local command=""
    if [[ $#@ -lt 2 ]]; then
        val="all"
    fi
    if [[ $#@ -lt 1 ]]; then
        command="check"
    fi
    if [[ $#@ -ge 2 ]]; then
        command=$1
        val=$2
    fi

    if [[ ${envs[(ie)$val]} -gt ${#envs} ]]; then
        if [[ $val != "all" ]]; then
            echo "INVALID ENVIRONMENT: $val"
            help
            exit 1
        fi
    fi

    if [[ ${cmds[(ie)$command]} -gt ${#cmds} ]]; then
        echo "INVALID COMMAND: $command"
        help
        exit 1
    fi

    ${val}_${command}
fi

